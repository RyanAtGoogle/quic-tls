<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Porting QUIC to Transport Layer Security (TLS)</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Notational Conventions"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Protocol Overview"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Handshake Overview"/>
<link href="#rfc.section.3" rel="Chapter" title="3 QUIC over TLS Structure"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Mapping of QUIC to QUIC over TLS"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Protocol and Version Negotiation"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Source Address Validation"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Record Protection"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 TLS Handshake Encryption"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Key Update"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Sequence Number Reconstruction"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Alternative Design: Exporters"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Pre-handshake QUIC Messages"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 QUIC Extension"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Unprotected Frames Prior to Handshake Completion"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 STREAM Frames"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 ACK Frames"/>
<link href="#rfc.section.6.2.3" rel="Chapter" title="6.2.3 WINDOW_UPDATE Frames"/>
<link href="#rfc.section.6.2.4" rel="Chapter" title="6.2.4 FEC Packets"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Protected Frames Prior to Handshake Completion"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Connection ID"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations"/>
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="10 References"/>
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Acknowledgments"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Thomson, M." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-thomson-quic-tls-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-3-21" />
  <meta name="dct.abstract" content="The QUIC experiment defines a custom security protocol.  This was necessary to gain handshake latency improvements.  This document describes how that security protocol might be replaced with TLS." />
  <meta name="description" content="The QUIC experiment defines a custom security protocol.  This was necessary to gain handshake latency improvements.  This document describes how that security protocol might be replaced with TLS." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">M. Thomson</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">March 21, 2016</td>
</tr>
<tr>
  <td class="left">Expires: September 22, 2016</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Porting QUIC to Transport Layer Security (TLS)<br />
  <span class="filename">draft-thomson-quic-tls-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>The QUIC experiment defines a custom security protocol.  This was necessary to gain handshake latency improvements.  This document describes how that security protocol might be replaced with TLS.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 22, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Notational Conventions</a></li>
</ul><li>2.   <a href="#rfc.section.2">Protocol Overview</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Handshake Overview</a></li>
</ul><li>3.   <a href="#rfc.section.3">QUIC over TLS Structure</a></li>
<li>4.   <a href="#rfc.section.4">Mapping of QUIC to QUIC over TLS</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Protocol and Version Negotiation</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Source Address Validation</a></li>
</ul><li>5.   <a href="#rfc.section.5">Record Protection</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">TLS Handshake Encryption</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Key Update</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Sequence Number Reconstruction</a></li>
<li>5.4.   <a href="#rfc.section.5.4">Alternative Design: Exporters</a></li>
</ul><li>6.   <a href="#rfc.section.6">Pre-handshake QUIC Messages</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">QUIC Extension</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Unprotected Frames Prior to Handshake Completion</a></li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">STREAM Frames</a></li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">ACK Frames</a></li>
<li>6.2.3.   <a href="#rfc.section.6.2.3">WINDOW_UPDATE Frames</a></li>
<li>6.2.4.   <a href="#rfc.section.6.2.4">FEC Packets</a></li>
</ul><li>6.3.   <a href="#rfc.section.6.3">Protected Frames Prior to Handshake Completion</a></li>
</ul><li>7.   <a href="#rfc.section.7">Connection ID</a></li>
<li>8.   <a href="#rfc.section.8">Security Considerations</a></li>
<li>9.   <a href="#rfc.section.9">IANA Considerations</a></li>
<li>10.   <a href="#rfc.references">References</a></li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Acknowledgments</a></li>
<li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">QUIC <a href="#I-D.tsvwg-quic-protocol">[I-D.tsvwg-quic-protocol]</a> provides a multiplexed transport for HTTP <a href="#RFC7230">[RFC7230]</a> semantics that provides several key advantages over HTTP/1.1 <a href="#RFC7230">[RFC7230]</a> or HTTP/2 <a href="#RFC7540">[RFC7540]</a> over TCP <a href="#RFC0793">[RFC0793]</a>.</p>
<p id="rfc.section.1.p.2">The custom security protocol designed for QUIC provides critical latency improvements for connection establishment.  Absent packet loss, most new connections can be established with a single round trip; on subsequent connections between the same client and server, the client can often send application data immediately, that is, zero round trip setup.  TLS 1.3 uses a similar design and aims to provide the same set of improvements.</p>
<p id="rfc.section.1.p.3">This document describes how the standardized TLS 1.3 might serve as a security layer for QUIC.  The same design could work for TLS 1.2, though few of the benefits QUIC provides would be realized due to the handshake latency in versions of TLS prior to 1.3.</p>
<p/>

<dl>
  <dt>Alternative Designs:</dt>
  <dd style="margin-left: 8">There are other designs that are possible; and many of these alternative designs are likely to be equally good.  The point of this document is to articulate a coherent single design.  Notes like this throughout the document are used describe points where alternatives were considered.</dd>
</dl>
<h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a></h2>
<p id="rfc.section.1.1.p.1">The words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221;, and &#8220;MAY&#8221; are used in this document.  It&#8217;s not shouting; when they are capitalized, they have the special meaning defined in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#protocol-overview" id="protocol-overview">Protocol Overview</a></h1>
<p id="rfc.section.2.p.1">QUIC <a href="#I-D.tsvwg-quic-protocol">[I-D.tsvwg-quic-protocol]</a> can be separated into several modules:</p>
<p/>

<ol>
  <li>The basic frame envelope describes the common packet layout.  This layer includes connection identification, version negotiation, and includes the indicators that allow the framing, public reset, and FEC modules to be identified.</li>
  <li>The public reset is an unprotected frame that allows an intermediary (an entity that is not part of the security context) to request the termination of a QUIC connection.</li>
  <li>The forward error correction (FEC) module provides redundant entropy that allows for frames to be repaired in event of loss.</li>
  <li>Framing comprises most of the QUIC protocol.  Framing provides a number of different types of frame, each with a specific purpose.  Framing supports frames for both congestion management and stream multiplexing.  Framing additionally provides a liveness testing capability (the PING frame).</li>
  <li>Crypto provides confidentiality and integrity protection for frames.  All frames are protected after the handshake completes on stream 1.  Prior to this, data is protected with the 0-RTT keys.</li>
  <li>Multiplexed streams are the primary payload of QUIC.  These provide reliable, in-order delivery of data and are used to carry the encryption handshake and transport parameters (stream 1), HTTP header fields (stream 3), and HTTP requests and responses.  Frames for managing multiplexing include those for creating and destroying streams as well as flow control and priority frames.</li>
  <li>Congestion management includes packet acknowledgment and other signal required to ensure effective use of available link capacity.</li>
  <li>HTTP mapping provides an adaptation to HTTP that is based on HTTP/2.</li>
</ol>
<p id="rfc.section.2.p.3">The relative relationship of these components are pictorally represented in <a href="#quic-structure">Figure 1</a>.</p>
<div id="rfc.figure.1"/>
<div id="quic-structure"/>
<pre>
   +----+------+
   | HS | HTTP |
   +----+------+------------+
   |  Streams  | Congestion |
   +-----------+------------+
   |        Frames          |
   +           +------------+
   |           |    FEC     +--------+
   +  +--------+------------+ Public |
   |  |     Crypto          | Reset  |
   +--+---------------------+--------+
   |              Envelope           |
   +---------------------------------+
   |                UDP              |
   +---------------------------------+

                             *HS = Crypto Handshake
</pre>
<p class="figure">Figure 1: QUIC Structure</p>
<p id="rfc.section.2.p.4">This document describes a replacement of the cryptographic parts of QUIC.  This includes the handshake messages that are exchanged on stream 1, plus the record protection that is used to encrypt and authenticate all other frames.</p>
<h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#handshake-overview" id="handshake-overview">Handshake Overview</a></h2>
<p id="rfc.section.2.1.p.1">TLS 1.3 provides two basic handshake modes of interest to QUIC:</p>
<p/>

<ul>
  <li>A full handshake in which the client is able to send application data after one round trip and the server immediately after receiving the first message from the client.</li>
  <li>A 0-RTT handshake in which the client uses information about the server to send immediately.  This data can be replayed by an attacker so it MUST NOT carry a self-contained trigger for any non-idempotent action.</li>
</ul>
<p id="rfc.section.2.1.p.3">A simplified TLS 1.3 handshake with 0-RTT application data is shown in <a href="#tls-full">Figure 2</a>, see <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> for more options.</p>
<div id="rfc.figure.2"/>
<div id="tls-full"/>
<pre>
    Client                                             Server

    ClientHello
   (Finished)
   (0-RTT Application Data)
   (end_of_early_data)        --------&gt;
                                                  ServerHello
                                         {EncryptedExtensions}
                                         {ServerConfiguration}
                                                 {Certificate}
                                           {CertificateVerify}
                                                    {Finished}
                             &lt;--------      [Application Data]
   {Finished}                --------&gt;

   [Application Data]        &lt;-------&gt;      [Application Data]
</pre>
<p class="figure">Figure 2: TLS Handshake with 0-RTT</p>
<p id="rfc.section.2.1.p.4">Two additional variations on this basic handshake exchange are relevant to this document:</p>
<p/>

<ul>
  <li>The server can respond to a ClientHello with a HelloRetryRequest, which adds an additional round trip prior to the basic exchange.  This is needed if the server wishes to request a different key exchange key from the client.  HelloRetryRequest might also be used to verify that the client is correctly able to receive packets on the address it claims to have (see <a href="#source-address">Section 4.2</a>).</li>
  <li>A pre-shared key mode can be used for subsequent handshakes to avoid public key operations.  This might be the basis for 0-RTT, even if the remainder of the connection is protected by a new Diffie-Hellman exchange.</li>
</ul>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#quic-over-tls-structure" id="quic-over-tls-structure">QUIC over TLS Structure</a></h1>
<p id="rfc.section.3.p.1">QUIC completes its cryptographic handshake on stream 1, which means that the negotiation of keying material happens within the QUIC protocol.  QUIC over TLS does the same, relying on the ordered delivery guarantees provided by QUIC to ensure that the TLS handshake packets are delivered reliably and in order.</p>
<div id="rfc.figure.3"/>
<div id="tls-quic-stack"/>
<pre>
   +-----+---------+
   | TLS |  HTTP   |
   +-----+----------+------------+
   |    Streams     | Congestion |
   +----------------+------------+
   |          Frames             |
   |                +------------+
   |                |    FEC     +--------+
   |     +----------+------------+ Public |
   |     | TLS Record Protection | Reset  |
   +-----+-----------------------+--------+
   |               Envelope               |
   +--------------------------------------+
   |                 UDP                  |
   +--------------------------------------+
</pre>
<p class="figure">Figure 3: QUIC over TLS</p>
<p id="rfc.section.3.p.2">In this design the QUIC envelope carries QUIC frames until the TLS handshake completes.  After the handshake successfully completes the key exchange, QUIC frames are then protected by TLS record protection.</p>
<p id="rfc.section.3.p.3">QUIC stream 1 is used to exchange TLS handshake packets.  QUIC provides for reliable and in-order delivery of the TLS handshake messages.</p>
<p id="rfc.section.3.p.4">Prior to the completion of the TLS handshake, QUIC frames can be exchanged.  However, these frames are not authenticated or confidentiality protected.  <a href="#pre-handshake">Section 6</a> covers some of the implications of this design.</p>
<p/>

<dl>
  <dt>Alternative Design:</dt>
  <dd style="margin-left: 8">TLS could be used to protect the entire QUIC envelope.  QUIC version negotiation could be subsumed by TLS and ALPN <a href="#RFC7301">[RFC7301]</a>.  The only unprotected packets are then public resets and ACK frames, both of which could be given first octet values that would easily distinguish them from other TLS packets.  This requires that the QUIC sequence numbers be moved to the outside of the record.</dd>
</dl>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#mapping-of-quic-to-quic-over-tls" id="mapping-of-quic-to-quic-over-tls">Mapping of QUIC to QUIC over TLS</a></h1>
<p id="rfc.section.4.p.1">Several changes to the structure of QUIC are necessary to make a layered design practical.</p>
<p id="rfc.section.4.p.2">These changes produce the handshake shown in <a href="#quic-tls-handshake">Figure 4</a>.  In this handshake, QUIC STREAM frames on stream 1 carry the TLS handshake.  QUIC is responsible for ensuring that the handshake packets are re-sent in case of loss and that they can be ordered correctly.</p>
<p id="rfc.section.4.p.3">QUIC operates without any record protection until the handshake completes, just as TLS over TCP does not include record protection for the handshake messages.  Once complete, QUIC frames and forward error control (FEC) messages are encapsulated in using TLS record protection.</p>
<div id="rfc.figure.4"/>
<div id="quic-tls-handshake"/>
<pre>
    Client                                             Server

   QUIC STREAM Frame &lt;stream 1&gt;
    ClientHello
     + QUIC Setup Parameters
   (Finished)                 --------&gt;
   (Replayable QUIC Frames &lt;any stream&gt;)
   (end_of_early_data &lt;1&gt;) --------&gt;
                                         QUIC STREAM Frame &lt;1&gt;
                                                  ServerHello
                                         {EncryptedExtensions}
                                         {ServerConfiguration}
                                                 {Certificate}
                                           {CertificateVerify}
                                                    {Finished}
                             &lt;--------       [QUIC Frames/FEC]
   QUIC STREAM Frame &lt;1&gt;
   {Finished}                --------&gt;

   [QUIC Frames/FEC]         &lt;-------&gt;       [QUIC Frames/FEC]
</pre>
<p class="figure">Figure 4: QUIC over TLS Handshake</p>
<p id="rfc.section.4.p.4">The remainder of this document describes the changes to QUIC and TLS that allow the protocols to operate together.</p>
<h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#version-negotiation" id="version-negotiation">Protocol and Version Negotiation</a></h2>
<p id="rfc.section.4.1.p.1">The QUIC version negotiation mechanism is used to negotiate the version of QUIC that is used prior to the completion of the handshake.  However, this packet is not authenticated, enabling an active attacker to force a version downgrade.</p>
<p id="rfc.section.4.1.p.2">To ensure that a QUIC version downgrade is not forced by an attacker, version information is copied into the TLS handshake, which provides integrity protection for the QUIC negotiation.  This doesn&#8217;t prevent version downgrade during the handshake, though it does prevent a connection from completing with a downgraded version, see <a href="#quic_parameters">Section 6.1</a>.</p>
<p/>

<dl>
  <dt>ISSUE:</dt>
  <dd style="margin-left: 8">The QUIC version negotiation has poor performance in the event that a client is forced to downgrade from their preferred version.</dd>
</dl>
<h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#source-address" id="source-address">Source Address Validation</a></h2>
<p id="rfc.section.4.2.p.1">QUIC implementations describe a source address token.  This is an opaque blob that a server provides to clients when they first use a given source address.  The client returns this token in subsequent messages as a return routeability check.  That is, the client returns this token to prove that it is able to receive packets at the source address that it claims.</p>
<p id="rfc.section.4.2.p.2">Since this token is opaque and consumed only by the server, it can be included in the TLS 1.3 configuration identifier for 0-RTT handshakes.  Servers that use 0-RTT are advised to provide new configuration identifiers after every handshake to avoid passive linkability of connections from the same client.</p>
<p id="rfc.section.4.2.p.3">A server that is under load might include the same information in the cookie extension/field of a HelloRetryRequest. (Note: the current version of TLS 1.3 does not include the ability to include a cookie in HelloRetryRequest.)</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#record-protection" id="record-protection">Record Protection</a></h1>
<p id="rfc.section.5.p.1">Each TLS record is encapsulated in the QUIC envelope.  This provides length information, which means that the length field can be dropped from the TLS record.</p>
<p id="rfc.section.5.p.2">The sequence number used by TLS record protection is changed to deal with the potential for packets to be dropped or lost.  The QUIC sequence number is used in place of the monotonically increasing TLS record sequence number.  This means that the TLS record protection employed is closer to DTLS in both its form and the guarantees that are provided.</p>
<p id="rfc.section.5.p.3">QUIC has a single, contiguous sequence number space.  In comparison, TLS restarts its sequence number each time that record protection keys are changed.  The sequence number restart in TLS ensures that a compromise of the current traffic keys does not allow an attacker to truncate the data that is sent after a key update by sending additional packets under the old key (causing new packets to be discarded).</p>
<p id="rfc.section.5.p.4">QUIC does not rely on there being a continuous sequence of application data packets; QUIC uses authenticated repair mechansims that operate above the layer of encryption.  QUIC can therefore operate without restarting sequence numbers.</p>
<h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#tls-handshake-encryption" id="tls-handshake-encryption">TLS Handshake Encryption</a></h2>
<p id="rfc.section.5.1.p.1">TLS 1.3 adds encryption for handshake messages.  This introduces an additional transition between different record protection keys during the handshake.  A consequence of this is that it becomes more important to explicitly identify the transition from one set of keys to the next (see <a href="#key-update">Section 5.2</a>).</p>
<h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#key-update" id="key-update">Key Update</a></h2>
<p id="rfc.section.5.2.p.1">Each time that the TLS record protection keys are changed, the message initiating the change could be lost.  This results in subsequent packets being indecipherable to the peer that receives them.  Key changes happen at the conclusion of the handshake and and immediately after a KeyUpdate message.</p>
<p id="rfc.section.5.2.p.2">TLS relies on an ordered, reliable transport and therefore provides no other mechanism to ensure that a peer receives the message initiating a key change prior to receiving the subsequent messages that are protected using the new key.  A similar mechanism here would introduce head-of-line blocking.</p>
<p id="rfc.section.5.2.p.3">The simplest solution here is to steal a single bit from the unprotected part of the QUIC header that signals key updates, similar to how DTLS signals the epoch on each packet.  The epoch bit is encoded into 0x80 of the QUIC public flags.</p>
<p id="rfc.section.5.2.p.4">Each time the epoch bit changes, an attempt is made to update the keys used to read.  Peers are prohibited from sending multiple KeyUpdate messages until they see a reciprocal KeyUpdate to prevent the chance that a transition is undetected as a result of two changes in this bit.</p>
<p id="rfc.section.5.2.p.5">The transition from cleartext to encrypted packets is exempt from this limit of one key change.  Two key changes occur during the handshake.  The server sends packets in the clear, plus packets protected using handshake and application data keys.  With only a single bit available to discriminate between keys, packets protected with the application data keys will have the same bit value as cleartext packets.  This condition will be easily identified and handled, likely by discarding the application data, since the encrypted packets will be highly unlikely to be valid.</p>
<h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#sequence-number-reconstruction" id="sequence-number-reconstruction">Sequence Number Reconstruction</a></h2>
<p id="rfc.section.5.3.p.1">Each peer maintains a 48-bit send sequence number that is incremented with each packet that is sent (even retransmissions).  The least significant 8-, 16-, 32-, or 48-bits of this number is encoded in the QUIC sequence number field in every packet.  A 16-bit send epoch number is maintained; the epoch is incremented each time new record protection keying material is used.  The least significant bit of the epoch number is encoded into the epoch bit (0x80) of the QUIC public flags.</p>
<p id="rfc.section.5.3.p.2">A receiver maintains the same values, but recovers values based on the packets it receives.  This is based on the sequence number of packets that it has received.  A simple scheme predicts the receive sequence number of an incoming packet by incrementing the sequence number of the most recent packet to be successfully decrypted by one and expecting the sequence number to be within a range centered on that value.  The receive epoch value is incremented each time that the epoch bit (0x80) changes.</p>
<p id="rfc.section.5.3.p.3">The sequence number used for record protection is the 64-bit value obtained by concatenating the epoch and sequence number, both in network byte order.</p>
<h2 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#alternative-design-exporters" id="alternative-design-exporters">Alternative Design: Exporters</a></h2>
<p id="rfc.section.5.4.p.1">An exporter could be used to provide keying material for a QUIC-specific record protection.  This could draw on the selected cipher suite and the TLS record protection design so that the overall effort required to design and analyze is kept minimal.</p>
<p id="rfc.section.5.4.p.2">One concern with using exporters is that TLS doesn&#8217;t define an exporter for use prior to the end of the handshake.  That means the creation of a special exporter for use in protecting 0-RTT data.  That&#8217;s a pretty sharp object to leave lying around, and it&#8217;s not clear what the properties we could provide.  (That doesn&#8217;t mean that there wouldn&#8217;t be demand for such a thing, the possibility has already been raised.)</p>
<p id="rfc.section.5.4.p.3">An exporter-based scheme might opt not to use the handshake traffic keys to protect QUIC packets during the handshake, relying instead on separate protection for the TLS handshake records.  This complicates implementations somewhat, so an exporter might still be used.</p>
<p id="rfc.section.5.4.p.4">In the end, using an exporter doesn&#8217;t alter the design significantly.  Given the risks, a modification to the record protocol is probably safer.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#pre-handshake" id="pre-handshake">Pre-handshake QUIC Messages</a></h1>
<p id="rfc.section.6.p.1">Implementations MUST NOT exchange data on any stream other than stream 1 prior to the TLS handshake completing.  However, QUIC requires the use of several types of frame for managing loss detection and recovery.  In addition, it might be useful to use the data acquired during the exchange of unauthenticated messages for congestion management.</p>
<p id="rfc.section.6.p.2">The actions that a peer takes as a result of receiving an unauthenticated packet needs tobe limited.  In particular, state established by these packets cannot be retained once record protection commences.</p>
<p id="rfc.section.6.p.3">There are several approaches possible for dealing with unauthenticated packets prior to handshake completion:</p>
<p/>

<ul>
  <li>discard and ignore them</li>
  <li>use them, but reset any state that is established once the handshake completes</li>
  <li>use them and authenticate them afterwards; failing the handshake if they can&#8217;t be authenticated</li>
  <li>save them and use them when they can be properly authenticated</li>
  <li>treat them as a fatal error</li>
</ul>
<p id="rfc.section.6.p.5">Different strategies are appropriate for different types of data.  This document proposes that all strategies are possible depending on the type of message.</p>
<p/>

<ul>
  <li>Transport parameters and options are made usable and authenticated as part of the TLS handshake (see <a href="#quic_parameters">Section 6.1</a>).</li>
  <li>Most unprotected messages are treated as fatal errors when received except for the small number necessary to permit the handshake to complete (see <a href="#pre-handshake-unprotected">Section 6.2</a>).</li>
  <li>Protected packets can be discarded, but can be saved and later used (see <a href="#pre-handshake-protected">Section 6.3</a>).</li>
</ul>
<h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#quic_parameters" id="quic_parameters">QUIC Extension</a></h2>
<p id="rfc.section.6.1.p.1">A client describes characteristics of the transport protocol it intends to conduct with the server in a new QUIC-specific extension in its ClientHello.  The server uses this information to determine whether it wants to continue the connection, request source address validation, or reject the connection.  Having this information unencrypted permits this check to occur prior to committing the resources needed to complete the initial key exchange.</p>
<p id="rfc.section.6.1.p.2">If the server decides to complete the connection, it generates a corresponding response and includes it in the EncryptedExtensions message.</p>
<p id="rfc.section.6.1.p.3">These parameters are not confidentiality-protected when sent by the client, but the server response is protected by the handshake traffic keys.  The entire exchange is integrity protected once the handshake completes.</p>
<p id="rfc.section.6.1.p.4">This information is not used by TLS, but can be passed to the QUIC protocol as initialization parmeters.</p>
<p id="rfc.section.6.1.p.5">The <samp>quic_parameters</samp> extension contains a declarative set of parameters that establish QUIC operating parameters and constrain the behaviour of a peer.  The connection identifier and version are first negotiated using QUIC, and are included in the TLS handshake in order to provide integrity protection.</p>
<pre>
   enum {
       receive_buffer(0),
       (65535)
   } QuicTransportParameterType;

   struct {
       QuicTransportParameterType type;
       uint32 value;
   } QuicTransportParameter;

   uint32 QuicVersion;

   enum {
       (65535)
   } QuicOption;

   struct {
       uint64 connection_id;
       QuicVersion quic_version;
       QuicVersion supported_quic_versions&lt;0..2^8-1&gt;;
       uint32 connection_initial_window;
       uint32 stream_initial_window;
       uint32 implicit_shutdown_timeout;
       QuicTransportParameter transport_parameters&lt;0..2^16-1&gt;;
       QuicOption options&lt;0..2^8-2&gt;;
   } QuicParametersExtension;
</pre>
<p id="rfc.section.6.1.p.6">This extension MUST be included if a QUIC version is negotiated.  A server MUST NOT negotiate QUIC if this extension is not present.</p>
<p id="rfc.section.6.1.p.7">Based on the values offered by a client a server MAY use the values in this extension to determine whether it wants to continue the connection, request source address validation, or reject the connection.  Since this extension is initially unencrypted, the server can use the information prior to committing the resources needed to complete a key exchange.</p>
<p id="rfc.section.6.1.p.8">If the server decides to use QUIC, this extension MUST be included in the EncryptedExtensions message.</p>
<p id="rfc.section.6.1.p.9">The parameters are:</p>
<p/>

<dl>
  <dt>connection_id:</dt>
  <dd style="margin-left: 8">The 64-bit connection identifier for the connection, as selected by the client.</dd>
  <dt>quic_version:</dt>
  <dd style="margin-left: 8">The currently selected QUIC version that is used for the connection.  This is the version negotiated using the unauthenticated QUIC version negotiation (<a href="#version-negotiation">Section 4.1</a>).</dd>
  <dt>supported_quic_versions:</dt>
  <dd style="margin-left: 8">This is a list of supported QUIC versions for each peer.  A client sends an empty list if the version of QUIC being used is their preferred version; however, a client MUST include their preferred version if this was not negotiated using QUIC version negotiation.  A server MUST include all versions that it supports in this list.</dd>
  <dt>connection_initial_window:</dt>
  <dd style="margin-left: 8">The initial value for the connection flow control window for the endpoint, in octets.</dd>
  <dt>connection_initial_window:</dt>
  <dd style="margin-left: 8">The initial value for the flow control window of new streams created by the peer endpoint, in octets.</dd>
  <dt>implicit_shutdown_timeout:</dt>
  <dd style="margin-left: 8">The time, in seconds, that a connection can remain idle before being implicitly shutdown.</dd>
  <dt>transport_parameters:</dt>
  <dd style="margin-left: 8">A list of parameters for the QUIC connection, expressed as key-value pairs of arbitrary length.  The QuicTransportParameterType identifies each parameter; duplicate types are not permitted and MUST be rejected with a fatal illegal_parameter alert.  Type values are taken from a single space that is shared by all QUIC versions.  <dl><dt>ISSUE:</dt><dd style="margin-left: 8">There is currently no way to update the value of parameters once the connection has started.  QUIC crypto provided a SCFG message that could be sent after the connection was established.</dd></dl><p> </p></dd>
  <dt>options:</dt>
  <dd style="margin-left: 8">A list of options that can be negotiated for a given connection.  These are set during the initial handshake and are fixed thereafter.  These options are used to enable or disable optional features in the protocol.  The set of features that are supported across different versions might vary.  A client SHOULD include all options that it is willing to use.  The server MAY select any subset of those options that apply to the version of QUIC that it selects.  Only those options selected by the server are available for use.  <dl><dt>Note:</dt><dd style="margin-left: 8">This sort of optional behaviour seems like it could be accommodated adequately by defining new versions of QUIC for each experiment.  However, as an evolving protocol, multiple experiments need to be conducted concurrently and continuously.  The options parameter provides a flexible way to regulate which experiments are enabled on a per-connection basis.</dd></dl><p> </p></dd>
</dl>
<h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#pre-handshake-unprotected" id="pre-handshake-unprotected">Unprotected Frames Prior to Handshake Completion</a></h2>
<p id="rfc.section.6.2.p.1">This section describes the handling of messages that are sent and received prior to the completion of the TLS handshake.</p>
<p id="rfc.section.6.2.p.2">Sending and receiving unprotected messages is hazardous.  Unless expressly permitted, receipt of an unprotected message of any kind MUST be treated as a fatal error.</p>
<h3 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#stream-frames" id="stream-frames">STREAM Frames</a></h3>
<p><samp>STREAM</samp> frames for stream 1 are permitted.  These carry the TLS handshake messages.</p>
<p id="rfc.section.6.2.1.p.2">Receiving unprotected <samp>STREAM</samp> frames that do not contain TLS handshake messages MUST be treated as a fatal error.</p>
<h3 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#ack-frames" id="ack-frames">ACK Frames</a></h3>
<p><samp>ACK</samp> frames are permitted prior to the handshake being complete.  However, an unauthenticated <samp>ACK</samp> frame can only be used to obtain NACK ranges.  Timestamps MUST NOT be included in an unprotected ACK frame, since these might be modified by an attacker with the intent of altering congestion control response.  Information on FEC-revived packets is redundant, since use of FEC in this phase is prohibited.</p>
<p><samp>ACK</samp> frames MAY be sent a second time once record protection is enabled.  Once protected, timestamps can be included.</p>
<p/>

<dl>
  <dt>Editor&#8217;s Note:</dt>
  <dd style="margin-left: 8">This prohibition might be a little too strong, but this is the only obviously safe option.  If the amount of damage that an attacker can do by modifying timestamps is limited, then it might be OK to permit the inclusion of timestamps.  Note that an attacker need not be on-path to inject an ACK.</dd>
</dl>
<h3 id="rfc.section.6.2.3"><a href="#rfc.section.6.2.3">6.2.3.</a> <a href="#windowupdate-frames" id="windowupdate-frames">WINDOW_UPDATE Frames</a></h3>
<p id="rfc.section.6.2.3.p.1">Sending a <samp>WINDOW_UPDATE</samp> on stream 1 might be necessary to permit the completion of the TLS handshake, particularly in cases where the certification path is lengthy.  To avoid stalling due to flow control exhaustion, <samp>WINDOW_UPDATE</samp> frames with stream 1 are permitted.</p>
<p id="rfc.section.6.2.3.p.2">Receiving a <samp>WINDOW_UPDATE</samp> frame on streams other than 1 MUST be treated as a fatal error.</p>
<p id="rfc.section.6.2.3.p.3">Stream 1 is exempt from the connection-level flow control window.</p>
<p id="rfc.section.6.2.3.p.4">The position of the flow control window MUST be reset to defaults once the TLS handshake is complete.  This might result in the window position for either the connection or stream 1 being smaller than the number of octets that have been sent on those streams.  A <samp>WINDOW_UPDATE</samp> frame might therefore be necessary to prevent the connection from being stalled.</p>
<p/>

<dl>
  <dt>Note:</dt>
  <dd style="margin-left: 8">This is only potentially problematic for servers, who might need to send large certificate chains.  This is unlikely given that QUIC - like HTTP <a href="#RFC7230">[RFC7230]</a> - is a protocol where the server is unable to exercise the opportunity TLS presents to send first.</dd>
  <dt></dt>
  <dd style="margin-left: 8">If later modifications or extensions to QUIC permit the server to send first, a client might reduce the chance of stalling due to flow control in this first round trip by setting larger values for the initial stream and connection flow control windows using the <samp>quic_parameters</samp> extension (<a href="#quic_parameters">Section 6.1</a>).</dd>
  <dt>Editor&#8217;s Note:</dt>
  <dd style="margin-left: 8">Unlike <samp>ACK</samp>, the prohibition on <samp>WINDOW_UPDATE</samp> is much less of an imposition on implementations.  And, given that a spurious <samp>WINDOW_UPDATE</samp> might be used to create a great deal of memory pressure on an endpoint, the restriction seems justifiable.  Besides, I understand this one a lot better.</dd>
</dl>
<h3 id="rfc.section.6.2.4"><a href="#rfc.section.6.2.4">6.2.4.</a> <a href="#fec-packets" id="fec-packets">FEC Packets</a></h3>
<p id="rfc.section.6.2.4.p.1">FEC packets MUST NOT be sent prior to completing the TLS handshake.  Endpoints MUST treat receipt of an unprotected FEC packet as a fatal error.</p>
<h2 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#pre-handshake-protected" id="pre-handshake-protected">Protected Frames Prior to Handshake Completion</a></h2>
<p id="rfc.section.6.3.p.1">Due to reordering and loss, protected packets might be received by an endpoint before the final handshake messages are received.  If these can be decrypted successfully, such packets MAY be stored and used once the handshake is complete.</p>
<p id="rfc.section.6.3.p.2">Unless expressly permitted below, encrypted packets MUST NOT be used prior to completing the TLS handshake, in particular the receipt of a valid Finished message and any authentication of the peer.  If packets are processed prior to completion of the handshake, an attacker might use the willingness of an implementation to use these packets to mount attacks.</p>
<p id="rfc.section.6.3.p.3">TLS handshake messages are covered by record protection during the handshake, once key agreement has completed.  This means that protected messages need to be decrypted to determine if they are TLS handshake messages or not.  Similarly, <samp>ACK</samp> and <samp>WINDOW_UPDATE</samp> frames might be needed to successfully complete the TLS handshake.</p>
<p id="rfc.section.6.3.p.4">Any timestamps present in <samp>ACK</samp> frames MUST be ignored rather than causing a fatal error.  Timestamps on protected frames MAY be saved and used once the TLS handshake completes successfully.</p>
<p id="rfc.section.6.3.p.5">An endpoint MUST save the last protected <samp>WINDOW_UPDATE</samp> frame it receives for each stream and apply the values once the TLS handshake completes.</p>
<p/>

<dl>
  <dt>Editor&#8217;s Note:</dt>
  <dd style="margin-left: 8">Ugh.  This last one is pretty ugly.  Maybe we should just make the TLS handshake exempt from flow control up to the Finished message.  Then we can prohibit unauthenticated <samp>WINDOW_UPDATE</samp> messages.  We would still likely want to account for the packets sent and received, since to do otherwise would create some hairy special cases.  That means that stalling is possible, but it means that we can avoid ugly rules like the above.</dd>
</dl>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#connection-id" id="connection-id">Connection ID</a></h1>
<p id="rfc.section.7.p.1">The QUIC connection identifier serves to identify a connection and to allow a server to resume an existing connection from a new client address in case of mobility events.  However, this creates an identifier that a passive observer <a href="#RFC7258">[RFC7258]</a> can use to correlate connections.</p>
<p id="rfc.section.7.p.2">TLS 1.3 offers connection resumption using pre-shared keys, which also allows a client to send 0-RTT application data.  This mode could be used to continue a connection rather than rely on a publicly visible correlator.  This only requires that servers produce a new ticket on every connection and that clients do not resume from the same ticket more than once.</p>
<p id="rfc.section.7.p.3">The advantage of relying on 0-RTT modes for mobility events is that this is also more robust.  If the new point of attachment results in contacting a new server instance - one that lacks the session state - then a fallback is easy.</p>
<p id="rfc.section.7.p.4">The main drawback with a clean restart or anything resembling a restart is that accumulated state can be lost.  Aside from progress on incomplete requests, the state of the HPACK header compression table could be quite valuable.  Existing QUIC implementations use the connection ID to route packets to the server that is handling the connection, which avoids this sort of problem.</p>
<p id="rfc.section.7.p.5">A lightweight state resurrection extension might be used to avoid having to recreate any expensive state.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.8.p.1">There are likely to be some real clangers here eventually, but the current set of issues is well captured in the relevant sections of the main text.</p>
<p id="rfc.section.8.p.2">Never assume that because it isn&#8217;t in the security considerations section it doesn&#8217;t affect security.  Most of this document does.</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.9.p.1">This document has no IANA actions.  Yet.</p>
<h1 id="rfc.references"><a href="#rfc.references">10.</a> References</h1>
<h2 id="rfc.references.1"><a href="#rfc.references.1">10.1.</a> Normative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-11">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-11, December 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.tsvwg-quic-protocol">[I-D.tsvwg-quic-protocol]</b>
      </td>
      <td class="top"><a>Hamilton, R.</a>, <a>Iyengar, J.</a>, <a>Swett, I.</a> and <a>A. Wilk</a>, "<a href="http://tools.ietf.org/html/draft-tsvwg-quic-protocol-02">QUIC: A UDP-Based Secure and Reliable Transport for HTTP/2</a>", Internet-Draft draft-tsvwg-quic-protocol-02, January 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7301">[RFC7301]</b>
      </td>
      <td class="top"><a>Friedl, S.</a>, <a>Popov, A.</a>, <a>Langley, A.</a> and <a>E. Stephan</a>, "<a href="http://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>", RFC 7301, DOI 10.17487/RFC7301, July 2014.</td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.references.2"><a href="#rfc.references.2">10.2.</a> Informative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC0793">[RFC0793]</b>
      </td>
      <td class="top"><a>Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7258">[RFC7258]</b>
      </td>
      <td class="top"><a>Farrell, S.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc7258">Pervasive Monitoring Is an Attack</a>", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.A.p.1">Christian Huitema&#8217;s knowledge of QUIC is far better than my own.  This would be even more inaccurate and useless if not for his assistance.  This document has variously benefited from a long series of discussions with Ryan Hamilton, Jana Iyengar, Adam Langley, Roberto Peon, Ian Swett, and likely many others who are merely forgotten by a faulty meat computer.</p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> 
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/martinthomson/quic-tls">Fork me on GitHub</a></div></div>
</body>
</html>
